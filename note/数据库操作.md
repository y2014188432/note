

# 数据库操作

### 查询语句（ DQL ）

#### 基本结构

- ```sql
    select 				#优先级    5
    	<返回字段名1、2、3> 
    from 				#优先级    1
    	<表名1、2、3> 
    where 				#优先级    2
    	<条件1、2、3>
    group by			#优先级    3
    	<分组依据>
    having				#优先级    4
    	<条件1、2、3>
    order by 			#优先级    6
    	<排序依据>;
    limit				#优先级    7   （mysql特有）
    	start,length
    ```

#### select （ 返回字段 ）

- 多字段使用逗号分割

    ```sql
    select a;
    select a,b;
    ```

- 可以使用数学运算

    ```sql
    select a*100;
    select b+50;
    ```

- 支持重命名，as 关键字可以省略

    ```sql
    select a as aa;
    select a aa;
    ```

- 可以进行去重

    ```sql
    select distinct a;
    select distinct a,b;
    ```

#### from （ 表名 ）

- 多表逗号分割

    ```sql
    from A;
    from A,B;
    ```

- 支持重命名

    ```sql
    from A as AA;
    from A AA;
    ```

#### where ( 条件 )

- 基本运算符

    ```sql
    > 、< 、>= 、<= 、!= 、<>
    ```

- between ... and

    ```mysql
    # 对于数字来说 相当于区间 [1,100]
    where num between 1 and 100;
    # 对于字符来说 相当于区间 [A,D)
    where c between A and D;
    ```

- 判空 / 非空

    ```mysql
    where param is null;
    where param is not null;
    ```

- 或 / 且

    ```sql
    where 判定式1 and 判定式2;
    where 判定式1 or 判定式2；
    ```

    

5. 分组函数（ 多行处理函数 ）

    - 在分组后生效，无 group by 时默认表为一组

    - 自动忽略 null 值
    - count（） 统计数量
    - min （）最小值
    - max （）最大值
    - avg （）平均值
    - sum （）求和

6. 单行处理函数

    - isnull（可能为空的列名，所要视为的数据）
    - 加减乘除等运算

- 关于表名

    1. 逗号分隔
    2. 可重命名

- 关于 where 条件

    1. 常见运算符号均可（ > 、< 、>= 、<= 、!= 、<> ）

    2. between <1> and <10> 等同于 [ 1 , 10 ]

        between <A> and <D> 等同于 [ A   ,  D )

    3. is null （is not null ）筛选出为空（不为空）的数据

    4. or （ and ）  或者（ 并且 ）

        优先级 and > or

        在不确定优先级的情况下，建议添加小括号来确保优先级

    5. in ( 数据1 、数据2 、、、 ) 筛选符合括号中的数据

    6. not 取非运算

    7. like 模糊查询

        ​	% 代表任意数量的字符

        ​	_ 代表一个字符

        ​	\  转义符号，用于转义 % 和  _

- 关于排序依据

    1. 默认升序排列
    2. 设定排序 ase 升序、desc 降序
    3. 多条件使用逗号分割
    
- 关于分组依据

    1. 使用 group by 后，select 后只能跟 分组函数以及参与分组的字段
    2. 可使用多字段联合分组

- 关于 having 条件

    1. 同 where ，优先级不同

- 连接查询

    - 基本语法

        ```mysql
        # SQL92 （ 不建议使用 ）
        select
        	..
        from
        	A a,B b
        where
        	连接条件、其他过滤条件
        # SQL99 （ 建议使用 ）
        select
        	..
        from
        	A a
        join
        	B b
        on
        	连接条件
        where
        	其他过滤条件
        ```

        

    - 内连接（ inner join ）

        1. 等值连接

            连接条件为等值的连接

        2. 非等值连接

            连接条件为区间范围的连接

        3. 自连接

            以自身为另一张表进行的连接

    - 外连接（ order join ）存在主表次表之分，在查询主表时顺带连接副表，副表匹配不上的自动生成 NULL

        1. 左外连接（左连接）（ left order join）以左边为主表
        2. 右外连接（右连接）（ right order join）以右边为主表

    - 全连接（很少用！）左右均为主表，互相匹配不上时互相生成 NULL
    
- 子查询

    1. 在 select 后的子查询
        - 一般不使用
    2. 在 from 后的子查询
        - 子查询的结果可以当作一张表进行后续的处理
    3. 在 where 后的子查询
        - 子查询使用分组函数可以得到一个或一些数据用于数据的过滤

- union

    - 连接两个 select 语句的执行结果
    - 返回的列数必须一致
    - 返回的列名为第一个 select 语句的列名

- limit

    1. MySQL 特有的
    2. 两个值，第一个是开始位置，第二个是长度
    3. 开始位置的省缺值为 0
    4. 位于语句的最后执行

#### DML 、 数据操作语句  、对数据操作

##### 数据的添加 、   insert

- 最常见单行数据输入

    ```mysql
    insert into 表名(列名1、列名2、列名3...) values (值1、值2、值3...);
    #列名不填时自动视为全部列名
    ```

- 注意事项

    1. 当一条 insert 语句执行完成后，数据库会增加一条数据，即使数据有所缺失，也只能在后续通过 update 更新

- 将其他 select 查询结果插入到表中

    ```mysql
    insert into 表名 select查询语句
    ```

- 注意事项

    1. select 查询语句的结果列数应该于所要插入的表的列数一致

##### 数据的更新  、 update

- 基本语法

    ```mysql
    update 表名 set 列名1=值1,列名2=值2... where 条件
    ```

- 注意事项

    1. set 后使用 逗号 分隔

##### 数据的删除 、 delete

- 基本语法（效率较低，可回滚）

    ```mysql
    delete from 表名 where 条件
    ```

- 截断式删除（效率高，不可回滚，数据永久丢失）

    ```mysql
    truncate table 表名
    ```

- 注意事项

    1. 使用 truncate 时务必谨慎，所造成的数据丢失是不可逆的

#### DDL 、数据定义语句  、对表操作

##### 表的创建  、create 

- 基本语法

    ```mysql
    create table t_表名(
    	列表名1 数据类型 约束条件
        列表名2 数据类型 约束条件	
        列表名3 数据类型 约束条件	
        列表名4 数据类型 约束条件	
        ...
    );
    # 可以将 select 查询语句的表直接创建成新表
    create table t_表名 as select查询语句;
    #  可以拷贝别的表的结构
    create table t_表名 like 表名;
    ```

- 数据类型

    1. int 			整型                同  java 中的 int
    2. bigint        长整型             同 Java 中的 long
    3. char         定长字符串       同 java 中的 string
    4. varchar    可变字符串       同 java 中的 stringBuffer / stringBuilding
    5. float         浮点型              同 java 中的 float
    6. data         日期                 同 java 中的 data
    7. BLOB       二进制大对象（例如图片、视频等） 储存使用 I/O 流
    8. CLOB       字节流大对象（例如长文本，最高可达 4G 的文本文件） 储存使用 I/O 流

- 约束条件

    1. 非空约束（ not null ）
        - 限制数据不能为空
        - 只能用于列级约束
    2. 主键约束（ primary key ）
        - 不能为空
        - 不能重复
        - 常用单一列名的列级约束
        - 建议使用自增主键
        - 建议使用跟业务无关的列名的自然主键
        - 一张表中只能存在一个主键
        - 作为一行数据在表中的唯一标识
        - 每张表中都应该存在主键
    3. 外键约束（ foreign key ）
        - foreign key  ( 列名 ) references 约束对象表名  ( 列名 )
        - 可以为 NULL
        - 约束源不一定为主键，但至少有 unique 约束
    4. 唯一约束（ unique ）
        - 限制行内数据均不能相同
        - 用于单列的被称为列级约束
        - 用于多列的被称为表级约束
    5. 默认约束（ default ）
        - 默认情况下 default 的值为 NULL
        - 可以设置未输入数据时的默认值
    6. 检查约束（ check ）
        - 检查输入内容是否合法
        - 表名  数据类型  check ( 表达式 )

#### DCL（ 数据控制语句 ）

- 

#### TCL（ 事务控制语句 ）

##### 事务的基本要素

- 是一个完整的逻辑单元
- 只对 DML 语句有效
- 目的是保证一组 DML 语句的同时成功或者同时失败
- 如果只用一条 DML 语句即可实现业务则不需要事务

##### 事务的实现流程

1. 开启事务
2. 执行 DML 语句，每执行一条，记录一下历史操作
3. 执行完成所有的 DML 语句
4. 提交或者回滚事务，改变或者放弃更改硬盘数据

##### 事务的四大特性 ACID

1. A 原子性：事务是最小的工作单元，不可再分
2. C 一致性：事务必须保障多条 DML 语句同时成功或者失败
3. I 隔离性：事务 A 于事务 B之间具有隔离
4. D 持久性：最终数据必须持久化到硬盘文件中，事务才算成功的结束

##### 事务隔离性级别

1. 第一级别：读未提交（ read uncomitted ）
    - 对方事务还没提交，当前事务就可以读取到对方为提交的数据
    - 缺陷：存在脏读（ dirty read ）现象，表示读到了脏的数据
2. 第二级别：读已提交（ read committed ）（其他数据库默认）
    - 对方事务提交之后的数据当前事务可以读到
    - 优点：解决了脏读现象
    - 缺陷：不可重复读
3. 第三级别：可重复读（ repeatable read ）（MySQL 默认）
    - 对方事务提交之后仍然读取不到
    - 优点：解决了不可重复读
    - 缺陷：读取到的数据可能缺失真实性
4. 第四级别：序列化读 / 串行化读
    - 在一个事务未结束之前，另一个事务不能够开启
    - 优点：解决了所有问题
    - 缺陷：效率低，需要事务排队

##### 事务操作

```mysql
start transaction;#关闭自动提交事务
DML				#DML语句
rollback;/commit;#提交或者回滚事务
```

#### 储存过程

##### 定义

- 相当于封装个函数
- 可以构造无参和有参方法

##### 注意事项

- 储存过程的每条语句都需要用分号分割，则要更改默认的结束符号

- ```sql
  delimiter // "或者"$$
  ```

- 结束构造后更改为默认值

- ```sql
  delimiter ;
  ```

##### 基本语句格式

- ```sql
  delimite //
  create procedure procedureName(parameter1,parameter2,parameter3,...)
  begin
  	语句1;
  	语句2;
  	...
  end //
  delimiter ;
  ```

  

### 非 SQL 语句

#### MySQL

- 显示当前数据库版本

    ```mysql
    select version();
    ```

- 以 sql 文件为数据源创建数据库

    ```mysql
    cource <文件路径>;
    ```

- 显示表结构

    ```mysql
    desc <表名>;
    ```

- 结束一条语句

    ```mysql
    \c
    ```

- 退出 mysql

    ```mysql
    exit；
    ```


#### 数据库引擎

1. InnoDB

    - MySQL 默认引擎
    - 支持事务，行级锁，外键，级联删除和级联更新
    - 在数据库崩溃时提供自动恢复机制
    - 存储在 xxx.frm 文件中
    - 无法被压缩，无法转换为只读

2. MeMory

    - 以前叫 HEPA
    - 不支持事务，数据容易丢失
    - 数据存储在内存之中，断电即丢失
    - 查询速度最快

3. MYISAM

    - 最常用的存储引擎

    - 不支持事务

    - 三张表存储数据

        xxx.frm（储存格式的文件）

        xxx.myd（ 储存表中数据的文件 ）

        xxx.myi（ 储存表中索引的文件 ）

    - 可被压缩，可转换为只读文件

#### 索引

##### 索引的创建和删除

```mysql
# 索引的创建
create index 索引名 on 表名（字段）
# 索引的删除
drop index 索引名 on 表名
```

##### 添加索引的要求

- 主键和 unique 数据库会自动添加索引
- 数据量庞大
- 字段频繁使用 where 判断
- 数据极少使用 DML 语句
- 索引在模糊查询第一个字符为任意字符时失效

##### 查看 DML 语句的执行计划

```mysql
explain DML语句
```

#### 视图

##### 基本属性

- 从不同角度看待表的方式
- 可以隐藏原表的构建细节，对数据库原表内容有较好的保密性
- 可以对视图进行 CRUD 操作，但仅限于由单表查询创建出的视图

##### 创建和删除

```mysql
#创建
create view 视图名 as select查询语句
#删除
drop view 视图名
```

#### DBA 命令

##### 导入数据库

1. 创建所需要的数据库名

2. use 数据库名

3. ```mysql
    source < sql 脚本文件 绝对路径>
    ```

##### 导出数据库

1. 在 Windows 的 dos 命令窗口下操作

2. ```mysql
    mysqldump 数据库名 表名（可选）  > 储存文件路径 -u 用户名 -p 密码
    ```

#### 设计三范式

##### 第一范式

- 所有表都应该存在主键
- 表中的字段名不能再分
- 单表设计的基础原则

##### 第二范式

- 在第一范式的基础上拓展
- 所有非主键必须完全依赖主键，不能产生部分依赖
- 主要处理多对多问题，将一张表拆解为三张表

##### 第三范式

- 在第二范式的基础上拓展
- 所有非主键必须完全依赖主键，不能产生传递依赖
- 主要处理一对多问题，将一张表拆解为两张表

##### 一对一关系

- 常见情况下为单表
- 部分情况下可将表拆解为两张表，可以采用 主键共享 / 外键唯一 方式进行拆解

##### 注意事项

1. 在实际开发过程中，可能会为了速度而产生冗余

#### 常见问题

##### count ( * ) count ( 1 )  count ( 列名 ) 之间的区别

1. 结果上来说
    1. count（ * ）包括所有列，相当于行数，统计行数时不会忽略掉 NULL 值
    2. count（ 1 ）忽略了所有列，用 1 代表代码行，统计行数时不会忽略掉 NULL 值
    3. count（ 列名 ）只含列名的那一列，在统计结果时会忽略掉 NULL 值
2. 性能上来说
    1. 当表中不存在主键时。多行，count（ 1 ）效率最优；单行，count（ * ）效率最优
    2. 所选列名为主键时，count（ 列名 ）效率最优，列名非主键时count（ 1 ）最优